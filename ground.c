#include <stdio.h>#include <stdlib.h>#include <GL/glut.h>#include <math.h>#include "head.h"#define PI (3.14159)#define tile_width 1.0//廊下のタイルの幅#define wall_width 1.25//塀の幅#define wall_height 4.0//塀の高さint width = 5;//廊下の幅double depth=25.0;//廊下の奥行GLfloat pos1[] = { 0.0, 0.0, 10.0, 1.0 };//player.cと重複した部分//enum COLOR { WHITE, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, GRAY, BLACK, LIGHTBLUE, GREENYELLOW, POWDERBLUE, FFFF33, FF6666, LEMONCHIFFON };/*player.cと重複した部分GLfloat color[][4] = {		{ 1.0, 1.0, 1.0, 1.0 },		{ 1.0, 0.0, 0.0, 1.0 },		{ 0.0, 1.0, 0.0, 1.0 },		{ 0.0, 0.0, 1.0, 1.0 },		{ 1.0, 1.0, 0.0, 1.0 },		{ 1.0, 0.0, 1.0, 1.0 },		{ 0.0, 1.0, 1.0, 1.0 },		{ 0.7, 0.7, 0.7, 1.0 },		{ 0.0, 0.0, 0.0, 1.0 },		{ 0.88, 1.0, 1.0, 1.0 },		{ 0.68, 1.0, 0.18, 1.0 },		{ 0.69, 0.88, 0.9, 1.0 },		{ 1.0, 1.0, 0.2, 1.0 },		{ 1.0, 0.4, 0.4, 1.0 },		{ 1.0, 0.98, 0.8, 1.0 } };//色を増やす場合はここに追加   */double x = 0;double y = 0;double z = 0;//int mySpecialValue = 1;int Flag = 0;//背景の変更void drawGround(){	int i, j;	GLdouble normal[3] = { 0.0, 0.0, 1.0 };	glPushMatrix();	glNormal3dv(normal);	if(Flag == 0){	glMaterialfv(GL_FRONT, GL_DIFFUSE, color[GREENYELLOW]);//ストライプの床タイル、黄緑	glMaterialfv(GL_FRONT, GL_AMBIENT, color[GREENYELLOW]);	glMaterialfv(GL_FRONT, GL_SPECULAR, color[WHITE]);	glMaterialf(GL_FRONT, GL_SHININESS, 100.0);	glBegin(GL_QUADS);	for (i = 0; i < 2; i++){		GLdouble v[4][3];		v[0][0] = (i*2 - 0.5)*tile_width; 		v[0][1] = -depth;		v[0][2] = 0.0;		v[1][0] = (i*2 - 0.5)*tile_width;		v[1][1] = 0.0;		v[1][2] = 0.0;		v[2][0] = (i*2 - 1.5)*tile_width;		v[2][1] = 0.0;		v[2][2] = 0.0;		v[3][0] = (i*2 - 1.5)*tile_width;		v[3][1] = -depth;		v[3][2] = 0.0;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);	}	glEnd();	glMaterialfv(GL_FRONT, GL_DIFFUSE, color[POWDERBLUE]);//ストライプの床タイル、薄水色	glMaterialfv(GL_FRONT, GL_AMBIENT, color[POWDERBLUE]);	glMaterialfv(GL_FRONT, GL_SPECULAR, color[WHITE]);	glMaterialf(GL_FRONT, GL_SHININESS, 100.0);	glBegin(GL_QUADS);	for (i = 0; i < 3; i++){		GLdouble v[4][3];		v[0][0] = (i*2 - 1.5)*tile_width; 		v[0][1] = -depth;		v[0][2] = 0.0;		v[1][0] = (i*2 - 1.5)*tile_width;		v[1][1] = 0.0;		v[1][2] = 0.0;		v[2][0] = (i*2 - 2.5)*tile_width;		v[2][1] = 0.0;		v[2][2] = 0.0;		v[3][0] = (i*2 - 2.5)*tile_width;		v[3][1] = -depth;		v[3][2] = 0.0;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);	}	glEnd();	glMaterialfv(GL_FRONT, GL_DIFFUSE, color[GREENYELLOW]);//ストライプの塀、黄緑	glMaterialfv(GL_FRONT, GL_AMBIENT, color[WHITE]);	glMaterialfv(GL_FRONT, GL_SPECULAR, color[WHITE]);	glMaterialf(GL_FRONT, GL_SHININESS, 100.0);	glBegin(GL_QUADS);	for (i = 0; i < 4; i += 2){//塀正面奥		GLdouble v[4][3];		v[0][0] = (i - 1)*wall_width; 		v[0][1] = -depth;		v[0][2] = wall_height;		v[1][0] = (i - 1)*wall_width;		v[1][1] = -depth;		v[1][2] = 0.0;		v[2][0] = (i - 2)*wall_width;		v[2][1] = -depth;		v[2][2] = 0.0;		v[3][0] = (i - 2)*wall_width;		v[3][1] = -depth;		v[3][2] = wall_height;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);	}	for (i = 0; i < 20; i += 2){//塀右側面		GLdouble v[4][3];		v[0][0] = wall_width*2; 		v[0][1] = -(i + 1)*wall_width;		v[0][2] = wall_height;		v[1][0] = wall_width*2;		v[1][1] = -i*wall_width;		v[1][2] = wall_height;		v[2][0] = wall_width*2;		v[2][1] = -i*wall_width;		v[2][2] = 0.0;		v[3][0] = wall_width*2;		v[3][1] = -(i + 1)*wall_width;		v[3][2] = 0.0;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);	}	for (i = 0; i < 20; i += 2){//塀左側面		GLdouble v[4][3];		v[0][0] = -wall_width*2; 		v[0][1] = -(i + 1)*wall_width;		v[0][2] = wall_height;		v[1][0] = -wall_width*2;		v[1][1] = -(i + 1)*wall_width;		v[1][2] = 0.0;		v[2][0] = -wall_width*2;		v[2][1] = -i*wall_width;		v[2][2] = 0.0;		v[3][0] = -wall_width*2;		v[3][1] = -i*wall_width;		v[3][2] = wall_height;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);	}	glEnd();	glMaterialfv(GL_FRONT, GL_DIFFUSE, color[POWDERBLUE]);//ストライプの塀、薄水色	glMaterialfv(GL_FRONT, GL_AMBIENT, color[WHITE]);	glMaterialfv(GL_FRONT, GL_SPECULAR, color[WHITE]);	glMaterialf(GL_FRONT, GL_SHININESS, 100.0);	glBegin(GL_QUADS);	for (i = 1; i < 4; i += 2){//塀正面奥		GLdouble v[4][3];		v[0][0] = (i - 1)*wall_width; 		v[0][1] = -depth;		v[0][2] = wall_height;		v[1][0] = (i - 1)*wall_width;		v[1][1] = -depth;		v[1][2] = 0.0;		v[2][0] = (i - 2)*wall_width;		v[2][1] = -depth;		v[2][2] = 0.0;		v[3][0] = (i - 2)*wall_width;		v[3][1] = -depth;		v[3][2] = wall_height;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);	}	for (i = 1; i < 20; i += 2){//塀右側面		GLdouble v[4][3];		v[0][0] = wall_width*2; 		v[0][1] = -(i + 1)*wall_width;		v[0][2] = wall_height;		v[1][0] = wall_width*2;		v[1][1] = -i*wall_width;		v[1][2] = wall_height;		v[2][0] = wall_width*2;		v[2][1] = -i*wall_width;		v[2][2] = 0.0;		v[3][0] = wall_width*2;		v[3][1] = -(i + 1)*wall_width;		v[3][2] = 0.0;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);	}	for (i = 1; i < 20; i += 2){//塀左側面		GLdouble v[4][3];		v[0][0] = -wall_width*2; 		v[0][1] = -(i + 1)*wall_width;		v[0][2] = wall_height;		v[1][0] = -wall_width*2;		v[1][1] = -(i + 1)*wall_width;		v[1][2] = 0.0;		v[2][0] = -wall_width*2;		v[2][1] = -i*wall_width;		v[2][2] = 0.0;		v[3][0] = -wall_width*2;		v[3][1] = -i*wall_width;		v[3][2] = wall_height;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);	}	glEnd();	}else if (Flag == 1){//スター状態になった時	glMaterialfv(GL_FRONT, GL_DIFFUSE, color[FFFF33]);//ダイヤモンドの床タイル、黄色	glMaterialfv(GL_FRONT, GL_AMBIENT, color[FFFF33]);	glMaterialfv(GL_FRONT, GL_SPECULAR, color[WHITE]);	glMaterialf(GL_FRONT, GL_SHININESS, 100.0);	glBegin(GL_QUADS);	for (i = 0; i < 25; i++){		for(j = 0; j < 5; j++){		GLdouble v[4][3];		v[0][0] = (j - 2)*tile_width; 		v[0][1] = -(i + 1)*tile_width;		v[0][2] = 0.0;		v[1][0] = (j - 1.5)*tile_width;		v[1][1] = -(i + 0.5)*tile_width;		v[1][2] = 0.0;		v[2][0] = (j - 2)*tile_width;		v[2][1] = -i*tile_width;		v[2][2] = 0.0;		v[3][0] = (j - 2.5)*tile_width;		v[3][1] = -(i + 0.5)*tile_width;		v[3][2] = 0.0;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);		}	}	glEnd();	glMaterialfv(GL_FRONT, GL_DIFFUSE, color[FF6666]);//ダイヤモンドの床タイル、ピンク色	glMaterialfv(GL_FRONT, GL_AMBIENT, color[FF6666]);	glMaterialfv(GL_FRONT, GL_SPECULAR, color[WHITE]);	glMaterialf(GL_FRONT, GL_SHININESS, 100.0);	glBegin(GL_QUADS);	for (i = 0; i < 26; i++){		for(j = 0; j < 6; j++){		GLdouble v[4][3];		v[0][0] = (j - 2.5)*tile_width; 		v[0][1] = -(i + 0.5)*tile_width;		v[0][2] = 0.0;		v[1][0] = (j - 2)*tile_width;		v[1][1] = -i*tile_width;		v[1][2] = 0.0;		v[2][0] = (j - 2.5)*tile_width;		v[2][1] = -(i - 0.5)*tile_width;		v[2][2] = 0.0;		v[3][0] = (j - 3)*tile_width;		v[3][1] = -i*tile_width;		v[3][2] = 0.0;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);		}	}	glEnd();		glMaterialfv(GL_FRONT, GL_DIFFUSE, color[FFFF33]);//ダイヤモンドの塀、黄色	glMaterialfv(GL_FRONT, GL_AMBIENT, color[WHITE]);	glMaterialfv(GL_FRONT, GL_SPECULAR, color[WHITE]);	glMaterialf(GL_FRONT, GL_SHININESS, 100.0);	glBegin(GL_QUADS);	for (i = 0; i < 5; i++){//塀正面奥		GLdouble v[4][3];		v[0][0] = (i - 2)*wall_width; 		v[0][1] = -depth;		v[0][2] = wall_height;		v[1][0] = (i - 1.5)*wall_width;		v[1][1] = -depth;		v[1][2] = wall_height*0.5;		v[2][0] = (i - 2)*wall_width;		v[2][1] = -depth;		v[2][2] = 0.0;		v[3][0] = (i - 2.5)*wall_width;		v[3][1] = -depth;		v[3][2] = wall_height*0.5;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);	}	for (i = 0; i < 11; i++){//塀右側面		GLdouble v[4][3];		v[0][0] = wall_width*2; 		v[0][1] = -i*wall_width*2;		v[0][2] = wall_height;		v[1][0] = wall_height*2;		v[1][1] = -(i - 0.5)*wall_width*2;		v[1][2] = wall_height*0.5;		v[2][0] = wall_width*2;		v[2][1] = -i*wall_width*2;		v[2][2] = 0.0;		v[3][0] = wall_width*2;		v[3][1] = -(i + 0.5)*wall_width*2;		v[3][2] = wall_height*0.5;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);	}	for (i = 0; i < 11; i++){//塀左側面		GLdouble v[4][3];		v[0][0] = -wall_width*2; 		v[0][1] = -i*wall_width*2;		v[0][2] = wall_height;		v[1][0] = -wall_width*2;		v[1][1] = -(i + 0.5)*wall_width*2;		v[1][2] = wall_height*0.5;		v[2][0] = -wall_width*2;		v[2][1] = -i*wall_width*2;		v[2][2] = 0.0;		v[3][0] = -wall_width*2;		v[3][1] = -(i - 0.5)*wall_width*2;		v[3][2] = wall_height*0.5;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);	}	glEnd();	glMaterialfv(GL_FRONT, GL_DIFFUSE, color[FF6666]);//ダイヤモンドの塀、ピンク色	glMaterialfv(GL_FRONT, GL_AMBIENT, color[WHITE]);	glMaterialfv(GL_FRONT, GL_SPECULAR, color[WHITE]);	glMaterialf(GL_FRONT, GL_SHININESS, 100.0);	glBegin(GL_TRIANGLES);	for (i = 0; i < 4; i++){//塀正面奥下		GLdouble v[3][3];		v[0][0] = (i - 2)*wall_width; 		v[0][1] = -depth;		v[0][2] = 0.0;		v[1][0] = (i - 1.5)*wall_width;		v[1][1] = -depth;		v[1][2] = 0.5*wall_height;		v[2][0] = (i - 1)*wall_width;		v[2][1] = -depth;		v[2][2] = 0.0;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);	}	for (i = 0; i < 4; i++){//塀正面奥上		GLdouble v[3][3];		v[0][0] = (i - 2)*wall_width; 		v[0][1] = -depth;		v[0][2] = wall_height;		v[1][0] = (i - 1)*wall_width;		v[1][1] = -depth;		v[1][2] = wall_height;		v[2][0] = (i - 1.5)*wall_width;		v[2][1] = -depth;		v[2][2] = wall_height*0.5;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);	}	for (i = 0; i < 10; i++){//塀右側面下		GLdouble v[3][3];		v[0][0] = wall_width*2; 		v[0][1] = -i*wall_width*2;		v[0][2] = 0.0;		v[1][0] = wall_width*2;		v[1][1] = -(i + 1)*wall_width*2;		v[1][2] = 0.0;		v[2][0] = wall_width*2;		v[2][1] = -(i + 0.5)*wall_width*2;		v[2][2] = wall_height*0.5;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);	}	for (i = 0; i < 20; i++){//塀右側面上		GLdouble v[3][3];		v[0][0] = wall_width*2; 		v[0][1] = -i*wall_width*2;		v[0][2] = wall_height;		v[1][0] = wall_width*2;		v[1][1] = -(i + 0.5)*wall_width*2;		v[1][2] = wall_height*0.5;		v[2][0] = wall_width*2;		v[2][1] = -(i + 1)*wall_width*2;		v[2][2] = wall_height;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);	}	for (i = 0; i < 10; i++){//塀左側面下		GLdouble v[3][3];		v[0][0] = -wall_width*2; 		v[0][1] = -i*wall_width*2;		v[0][2] = 0.0;		v[1][0] = -wall_width*2;		v[1][1] = -(i + 0.5)*wall_width*2;		v[1][2] = 0.5*wall_height;		v[2][0] = -wall_width*2;		v[2][1] = -(i + 1)*wall_width*2;		v[2][2] = 0.0;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);	}	for (i = 0; i < 10; i++){//塀左側面上		GLdouble v[3][3];		v[0][0] = -wall_width*2; 		v[0][1] = -i*wall_width*2;		v[0][2] = wall_height;		v[1][0] = -wall_width*2;		v[1][1] = -(i + 1)*wall_width*2;		v[1][2] = wall_height;		v[2][0] = -wall_width*2;		v[2][1] = -(i + 0.5)*wall_width*2;		v[2][2] = wall_height*0.5;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);	}	glEnd();	}	glMaterialfv(GL_FRONT, GL_DIFFUSE, color[WHITE]);//ダイヤモンドタイル除去	//glMaterialfv(GL_FRONT, GL_AMBIENT, color[WHITE]);	glMaterialfv(GL_FRONT, GL_SPECULAR, color[WHITE]);	glMaterialf(GL_FRONT, GL_SHININESS, 100.0);	glBegin(GL_QUADS);	GLdouble v[4][3];		v[0][0] = 2.5;//手前の床		v[0][1] = 0.0;		v[0][2] = 0.001;		v[1][0] = 2.5;		v[1][1] = 0.5;		v[1][2] = 0.001;		v[2][0] = -2.5;		v[2][1] = 0.5;		v[2][2] = 0.001;		v[3][0] = -2.5;		v[3][1] = 0.0;		v[3][2] = 0.001;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);			v[0][0] = -2.5 + 0.001;//手前左側塀		v[0][1] = 0.0;		v[0][2] = wall_height;		v[1][0] = -2.5 + 0.001;		v[1][1] = 0.0;		v[1][2] = 0.0;		v[2][0] = -2.5 + 0.001;		v[2][1] = 2.0;		v[2][2] = 0.0;		v[3][0] = -2.5 + 0.001;		v[3][1] = 2.0;		v[3][2] = wall_height;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);			v[0][0] = 2.5 - 0.001;//手前右側塀		v[0][1] = 2.0;		v[0][2] = wall_height;		v[1][0] = 2.5 - 0.001;		v[1][1] = 2.0;		v[1][2] = 0.0;		v[2][0] = 2.5 - 0.001;		v[2][1] = 0.0;		v[2][2] = 0.0;		v[3][0] = 2.5 - 0.001;		v[3][1] = 0.0;		v[3][2] = wall_height;		glVertex3dv(v[0]);		glVertex3dv(v[1]);		glVertex3dv(v[2]);		glVertex3dv(v[3]);	glEnd();	glPopMatrix();}